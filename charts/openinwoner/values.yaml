global:
  settings:
    # -- Global databasehost, overrides setting.database.host
    databaseHost: ""
  configuration:
    enabled: false
    secrets: {}

configuration:
  enabled: false
  initContainer:
    # -- Run the setup configuration command in a init container
    enabled: false
  job:
    # -- Run the setup configuration command as a job
    enabled: true
    backoffLimit: 6
    # -- 0 Will clean the job after it is finished
    ttlSecondsAfterFinished: 0    
    restartPolicy: OnFailure
    # Note, this field is immutable
    resources: {}
      # limits:
      #   cpu: 200m
      #   memory: 256Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi
  secrets: {}
  data: ""
  # e.g.
  # data: |-
  #   oidc_db_config_enable: True
  #   oidc_db_config_admin_auth:
  #     items:
  #     - identifier: admin-oidc
  #       enabled: True
  #       oidc_rp_client_id: openinwoner.example.nl 
  #       oidc_rp_client_secret:
  #         value_from:
  #           env: keycloak_client_secret   
  #       oidc_rp_scopes_list:
  #       - openid
  #       - email
  #       - profile
  #       - roles
  #       oidc_rp_sign_algo: RS256
  #       endpoint_config:
  #         oidc_op_discovery_endpoint: https://keycloak.example.nl/realms/example/
  #       username_claim:
  #       - sub
  #       groups_claim:
  #       - roles
  #       claim_mapping:
  #         first_name:
  #         - given_name
  #         last_name:
  #         - family_name
  #       sync_groups: true
  #       sync_groups_glob_pattern: "*"
  #       default_groups: []
  #       make_users_staff: true
  #       superuser_group_names:
  #       - Superuser
  #       oidc_use_nonce: true
  #       oidc_nonce_size: 32
  #       oidc_state_size: 32
  #       userinfo_claims_source: id_token
  #   zgw_consumers_config_enable: True
  #   zgw_consumers:
  #     services:
  #       - identifier: zaken-test
  #         label: Open Zaak - Zaken API
  #         api_root: https://openzaak.example.nl/zaken/api/v1/
  #         api_type: zrc
  #         auth_type: zgw
  #         client_id: openinwoner
  #         secret:
  #           value_from:
  #             env: openzaak_openinwoner_secret 
  #       - identifier: documenten-test
  #         label: Open Zaak - Documenten API
  #         api_root: https://openzaak.example.nl/documenten/api/v1/
  #         api_type: drc
  #         auth_type: zgw
  #         client_id: openinwoner
  #         secret:
  #           value_from:
  #             env: openzaak_openinwoner_secret
  #       - identifier: catalogi-test
  #         label: Open Zaak - Catalogi API
  #         api_root: https://openzaak.example.nl/catalogi/api/v1/
  #         api_type: ztc
  #         auth_type: zgw
  #         client_id: openinwoner
  #         secret:
  #           value_from:
  #             env: openzaak_openinwoner_secret
  #       - identifier: besluiten-test
  #         label: Open Zaak - Besluiten API
  #         api_root: https://openzaak.example.nl/besluiten/api/v1/
  #         api_type: brc
  #         auth_type: zgw
  #         client_id: openinwoner
  #         secret:
  #           value_from:
  #             env: openzaak_openinwoner_secret
  #       - identifier: selectielijst
  #         label: Open Zaak (public) - Selectielijst API
  #         api_root: https://selectielijst.openzaak.nl/api/v1/
  #         api_type: orc
  #         auth_type: no_auth
  #       - identifier: klanten-test
  #         label: Open klanten API
  #         api_root: https://openklant.example.nl/klanten/api/v1/
  #         api_type: kc
  #         auth_type: zgw
  #         client_id: openinwoner
  #         secret:
  #           value_from:
  #             env: openklant_openinwoner_token
  #   openzaak_config_enable: true
  #   openzaak_config:
  #     zaak_max_confidentiality: openbaar
  #     document_max_confidentiality: vertrouwelijk
  #     max_upload_size: 50
  #     skip_notification_statustype_informeren: false
  #     reformat_esuite_zaak_identificatie: true
  #     derive_zaak_titel_from: zaaktype_omschrijving
  #     order_statuses_by_date_set: false
  #     title_text: title text from setup configuration
  #     enable_categories_filtering_with_zaken: true
  #     action_required_deadline_days: 1874
  #     zaken_filter_enabled: 'true'
  #     allowed_file_extensions:
  #       - .pdf
  #       - .txt
  #     api_groups:
  #       - zaken_api_identifier: zaken-test
  #         documenten_api_identifier: documenten-test
  #         catalogi_api_identifier: catalogi-test
  #         fetch_eherkenning_zaken_with_rsin: true
  #   openklant_config_enable: false
  #   # OpenKlant2
  #   openklant2_config_enable: true
  #   openklant2_config:
  #     service_identifier: klanten-test
  #     mijn_vragen_kanaal: formulier
  #     mijn_vragen_organisatie_naam: De Gemeente
  #     mijn_vragen_actor: e412c6f6-bc31-4fd4-b883-0fb5e88d3f5b
  #     interne_taak_gevraagde_handeling: Vraag beantwoorden
  #     interne_taak_toelichting: Vraag via OIP, graag beantwoorden

tags:
  redis: true
  elasticsearch: true

replicaCount: 2

image:
  repository: maykinmedia/open-inwoner
  pullPolicy: IfNotPresent
  # -- uses .Chart.AppVersion by default
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  annotations: {}
  name: ""
  automountServiceAccountToken: true

podAnnotations: {}

podLabels: {}

podSecurityContext:
  fsGroup: 1000

securityContext:
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: false
  runAsNonRoot: true
  runAsUser: 1000

startupProbe:
  # -- Startup probe configuration - allows up to 5 minutes for application startup
  # -- Total time: 15s initial delay + (30 failures Ã— 10s period) = 315s (5 minutes 15 seconds)    
  initialDelaySeconds: 15
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 30
  successThreshold: 1

livenessProbe:
  initialDelaySeconds: 60
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

readinessProbe:
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: false
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  className: ""
  # -- ingress hosts
  hosts: []
  #  - host: openinwoner.gemeente.nl
  #    paths:
  #      - path: /
  #        pathType: ImplementationSpecific
  tls: []
  #  - secretName: openinwoner-tls
  #    hosts:
  #      - openinwoner.gemeente.nl

extraIngress: []
# e.g:
# extraIngress:
#  - name: openinwoner-azuregateway
#    annotations:
#      appgw.ingress.kubernetes.io/ssl-redirect: "true"
#    className: azure-application-gateway
#    hosts:
#      - host: openinwoner.gemeente.nl
#        paths:
#          - path: /
#            pathType: ImplementationSpecific
#            servicename: openklant
#            portNumber: 8000
#    tls:
#      - secretName: openinwoner-tls
#        hosts:
#          - "openinwoner.gemeente.nl"

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 1000m
  #   memory: 2Gi
  # requests:
  #   cpu: 500m
  #   memory: 1Gi

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

pdb:
  create: false
  minAvailable: 1
  maxUnavailable: ""

nodeSelector: {}

tolerations: []

affinity: {}

persistence:
  enabled: true
  size: 1Gi
  storageClassName: ""
  existingClaim: null
  mediaMountSubpath: openinwoner/media
  privateMediaMountSubpath: openinwoner/private_media

# Existing Secret must be defined for AzureVaultSecret to work
existingSecret: null
existingConfigurationSecrets: null

# This will create an AzureVaultSecret object in k8s, only Multi Key Value Secret are supported by this chart
# ref: https://akv2k8s.io/tutorials/sync/4-multi-key-value-secret/ https://learn.microsoft.com/en-us/azure/key-vault/secrets/multiline-secrets
# Using this feature requires you to define existingSecret
azureVaultSecret:
  # The name of the Azure Key Vault, setting this will create the AzureVaultSecret
  vaultName: null
  # The name of the Multi Key Value Secret
  objectName: ""
  # Make sure this matches the content of the secret, can be either 'application/x-json' or 'application/x-yaml'
  contentType: ""
  # You must set .Values.existingSecret
  secretName: "{{ .Values.existingSecret }}"

# -- Array with extra environment variables to add
extraEnvVars: []
# e.g:
# extraEnvVars:
#   - name: FOO
#     value: "bar"

# -- Optionally specify extra list of additional volumes
extraVolumes: []
# e.g:
# extraVolumes:
#   - name: verify-certs
#     configMap:
#       name: verify-certs

# -- Optionally specify extra list of additional volumeMounts
extraVolumeMounts: []
# e.g:
# extraVolumeMounts:
#  - name: verify-certs
#    mountPath: /etc/ssl/certs/extra-certs/

# -- Extra objects to deploy (value evaluated as a template)
extraDeploy: []

settings:
  allowedHosts: ""
  djangoSettingsModule: open_inwoner.conf.docker

  # -- Will load all fixtures in /app/src/open_inwoner/conf/fixtures/*.json
  loadFixtures: false

  # -- Elasticsearch hostname, only required when tags.elasticsearch is false
  elasticSearchHost: ""

  # -- Generate secret key at https://djecrety.ir/
  secretKey: ""

  # -- This optional setting can be used to rotate a secret key, by moving a new value
  # into secretKey, and moving the previous secretKey into secretKeyFallback. 
  secretKeyFallback: ""

  environment: null

  database:
    host: ""
    port: 5432
    name: ""
    username: ""
    password: ""
    sslmode: prefer

  email:
    host: localhost
    port: 25
    username: ""
    password: ""
    useTLS: false
    defaultFrom: ""

  elasticapm:
    url: ""
    token: ""

  smsgateway:
    # -- For example "open_inwoner.accounts.gateways.MessageBird"
    backend: ""
    apikey: ""

  brpVersion: ""

  digidMock: ""
  eherkenningMock: ""

  sentry:
    dsn: ""

  cache:
    # -- Sets 'CACHE_DEFAULT' var, only required when tags.redis is false
    default: ""
    # -- Sets 'CACHE_AXES' var, only required when tags.redis is false
    axes: ""
    # When not using the redis subcharts you can set them manually like this:
    # default: myredisserver:6379/0
    # axes: myredisserver:6379/0

  # Celery cache settings, when the redis subchart is enabled these settings will be ignored and caching will default to the redis subchart services
  celery:
    # e.g.:
    # brokerUrl: redis://openforms-redis-master:6379/1
    # resultBackend: redis://openforms-redis-master:6379/1
    brokerUrl: ""
    resultBackend: ""
    logLevel: debug

  isHttps: true

  debug: false

  uwsgi:
    threads: ""
    processes: ""
    maxRequests: ""
    harakiri: ""
    port: ""
    httpTimeout: ""
    httpKeepalive: ""
    # In bytes:
    postBuffering: ""
    bufferSize: ""

  # -- Runs a init container that will run /app/src/manage.py search_index --rebuild -f. You might want to enable this one time for new deployments if you want to prevent 500 errors when using the search function
  searchIndexInitContainer: false
  # -- Custom JavaScript Configuration
  # Flag to enable the custom JavaScript upload feature in the admin interface. When set to true, this feature allows admins to upload custom JavaScript code that will be loaded on all pages.
  # WARNING: Custom JavaScript can negatively impact security and performance, and should be done with care.
  # NOTE: This variable can only be set to true with openinwoner version 1.35.0 or higher
  allowCustomJs: false

  # -- Whether to provide a id_token_hint to the IdP broker when initiating a
  # frontchannel logout
  oidcFrontendLogoutWithHints: true

  # -- The maximum number of requests allowed for fetching zaken on the Mijn Zaken page.
  # The total number of zaken fetched will be this number multiplied by the page size
  # of the ZGW backend's zaken endpoint.
  zgwMaxRequests: ""

worker:
  replicaCount: 2
  concurrency: 4
  podLabels: {}
  resources: {}
    # requests:
    #   cpu: 250m
    #   memory: 256Mi
  # Defaults to 60s
  maxWorkerLivenessDelta: ""
  livenessProbe:
    enabled: false
    exec:
      command:
        - /bin/sh
        - -c
        - celery --workdir src --app open_inwoner.celery inspect --destination celery@${HOSTNAME} active
    initialDelaySeconds: 60
    # Periodeseconds should not exceed maxWorkerLivenessDelta
    periodSeconds: 50
    timeoutSeconds: 10
    failureThreshold: 3
    successThreshold: 1
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80

beat:
  replicaCount: 1
  podLabels: {}
  resources: {}
    # requests:
    #   cpu: 250m
    #   memory: 256Mi

celeryMonitor:
  replicaCount: 1
  podLabels: {}
  resources: {}
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

nginx:
  image:
    repository: nginxinc/nginx-unprivileged
    pullPolicy: IfNotPresent
    tag: stable
  config:
    clientMaxBodySize: 10M
    proxyConnectTimeoutSeconds: 300
    proxyReadTimeoutSeconds: 300
    # -- Configure nginx basic authentication, only use if you are unable to set it on your ingress controller
    basicAuth:
      # -- Enables nginx basic password authentication
      enabled: false
      # -- You need to generate the encrypted basic auth password yourself
      users: |-
        usernameexample:$apr1$5QwE2Ysc$ycRucgmLt0iQMMxcnu4CA/
  # extraVolumes Optionally specify extra list of additional volumes
  # e.g:
  # extraVolumes:
  #   - name: tmp
  #     emptyDir: {}
  #
  extraVolumes: []
  # extraVolumeMounts Optionally specify extra list of additional volumeMounts
  # e.g:
  # extraVolumeMounts:
  #   - name: tmp
  #     mountPath: /tmp
  extraVolumeMounts: []
  service:
    type: ClusterIP
    port: 80
    annotations: {}
  replicaCount: 1
  podLabels: {}
  securityContext:
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: false
    runAsNonRoot: true
    runAsUser: 101
  autoscaling:
    enabled: false
  livenessProbe:
    initialDelaySeconds: 60
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  readinessProbe:
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  resources: {}
    # requests:
    #   cpu: 250m
    #   memory: 256Mi


##################
# Redis subchart #
##################

redis:
  architecture: standalone
  auth:
    enabled: false
  master:
    persistence:
      enabled: true
      size: 8Gi
      storageClass: ""
    resources:
      requests:
        cpu: 250m
        memory: 256Mi
  # -- Redis image configuration - Migration from Bitnami to official Redis image          
  image:
    registry: docker.io  # Docker registry for Redis image
    repository: redis  # Official Redis image (migrated from Bitnami)
    tag: "8.0"  # Official Redis image pinned version

#########################
# ECK-Operator subchart #
#########################

eck-operator:
  enabled: true
  # nameOverride is the short name for the deployment. Leave empty to let Helm generate a name using chart values.
  nameOverride: "openinwoner-elastic-operator"

  # fullnameOverride is the full name for the deployment. Leave empty to let Helm generate a name using chart values.
  fullnameOverride: "openinwoner-elastic-operator"

  # managedNamespaces is the set of namespaces that the operator manages. Leave empty to manage all namespaces.
  managedNamespaces: []

  # installCRDs determines whether Custom Resource Definitions (CRD) are installed by the chart.
  # Note that CRDs are global resources and require cluster admin privileges to install.
  # If you are sharing a cluster with other users who may want to install ECK on their own namespaces, setting this to true can have unintended consequences.
  # 1. Upgrades will overwrite the global CRDs and could disrupt the other users of ECK who may be running a different version.
  # 2. Uninstalling the chart will delete the CRDs and potentially cause Elastic resources deployed by other users to be removed as well.
  installCRDs: false

  # replicaCount is the number of operator pods to run.
  replicaCount: 1

  image:
    # repository is the container image prefixed by the registry name.
    repository: docker.elastic.co/eck/eck-operator
    # pullPolicy is the container image pull policy.
    pullPolicy: IfNotPresent
    # tag is the container image tag. If not defined, defaults to chart appVersion.
    tag: null
    # fips specifies whether the operator will use a FIPS compliant container image for its own StatefulSet image.
    # This setting does not apply to Elastic Stack applications images.
    # Can be combined with config.ubiOnly.
    fips: false

  # priorityClassName defines the PriorityClass to be used by the operator pods.
  priorityClassName: ""

  # imagePullSecrets defines the secrets to use when pulling the operator container image.
  imagePullSecrets: []

  # resources define the container resource limits for the operator.
  resources:
    limits:
      cpu: 1
      memory: 1Gi
    requests:
      cpu: 100m
      memory: 150Mi

  # statefulsetAnnotations define the annotations that should be added to the operator StatefulSet.
  statefulsetAnnotations: {}

  # statefulsetLabels define additional labels that should be added to the operator StatefulSet.
  statefulsetLabels: {}

  # podAnnotations define the annotations that should be added to the operator pod.
  podAnnotations: {}

  ## podLabels define additional labels that should be added to the operator pod.
  podLabels: {}

  # podSecurityContext defines the pod security context for the operator pod.
  podSecurityContext:
    runAsNonRoot: true

  # securityContext defines the security context of the operator container.
  securityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
    readOnlyRootFilesystem: true
    runAsNonRoot: true

  # nodeSelector defines the node selector for the operator pod.
  nodeSelector: {}

  # tolerations defines the node tolerations for the operator pod.
  tolerations: []

  # affinity defines the node affinity rules for the operator pod.
  affinity: {}

  # podDisruptionBudget configures the minimum or the maxium available pods for voluntary disruptions,
  # set to either an integer (e.g. 1) or a percentage value (e.g. 25%).
  podDisruptionBudget:
    enabled: false
    minAvailable: 1
    # maxUnavailable: 3

  # additional environment variables for the operator container.
  env: []

  # additional volume mounts for the operator container.
  volumeMounts: []

  # additional volumes to add to the operator pod.
  volumes: []

  # createClusterScopedResources determines whether cluster-scoped resources (ClusterRoles, ClusterRoleBindings) should be created.
  createClusterScopedResources: true

  # Automount API credentials for the Service Account into the pod.
  automountServiceAccountToken: true

  serviceAccount:
    # create specifies whether a service account should be created for the operator.
    create: true
    # Specifies whether a service account should automount API credentials.
    automountServiceAccountToken: true
    # annotations to add to the service account
    annotations: {}
    # name of the service account to use. If not set and create is true, a name is generated using the fullname template.
    name: ""

  tracing:
    # enabled specifies whether APM tracing is enabled for the operator.
    enabled: false
    # config is a map of APM Server configuration variables that should be set in the environment.
    config:
      ELASTIC_APM_SERVER_URL: http://localhost:8200
      ELASTIC_APM_SERVER_TIMEOUT: 30s

  refs:
    # enforceRBAC specifies whether RBAC should be enforced for cross-namespace associations between resources.
    enforceRBAC: false

  webhook:
    # enabled determines whether the webhook is installed.
    enabled: true
    # caBundle is the PEM-encoded CA trust bundle for the webhook certificate. Only required if manageCerts is false and certManagerCert is null.
    caBundle: Cg==
    # certManagerCert is the name of the cert-manager certificate to use with the webhook.
    certManagerCert: null
    # certsDir is the directory to mount the certificates.
    certsDir: "/tmp/k8s-webhook-server/serving-certs"
    # failurePolicy of the webhook.
    failurePolicy: Ignore
    # manageCerts determines whether the operator manages the webhook certificates automatically.
    manageCerts: true
    # namespaceSelector corresponds to the namespaceSelector property of the webhook.
    # Setting this restricts the webhook to act only on objects submitted to namespaces that match the selector.
    namespaceSelector: {}
    # objectSelector corresponds to the objectSelector property of the webhook.
    # Setting this restricts the webhook to act only on objects that match the selector.
    objectSelector: {}
    # port is the port that the validating webhook binds to.
    port: 9443
    # secret specifies the Kubernetes secret to be mounted into the path designated by the certsDir value to be used for webhook certificates.
    certsSecret: ""

  # hostNetwork allows a Pod to use the Node network namespace.
  # This is required to allow for communication with the kube API when using some alternate CNIs in conjunction with webhook enabled.
  # If hostNetwork is enabled, dnsPolicy defaults to ClusterFirstWithHostNet unless explicitly set.
  # CAUTION: Proceed at your own risk. This setting has security concerns such as allowing malicious users to access workloads running on the host.
  hostNetwork: false

  # dnsPolicy defines the DNS policy for the operator pod.
  # Check https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy for more details.
  dnsPolicy: ""

  # dnsConfig defines the DNS configuration for the operator pod.
  # Check https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-dns-config for more details.
  # dnsConfig:
  #   nameservers:
  #     - 169.254.20.10
  #   searches:
  #     - svc.cluster.local
  #   options:
  #     - name: ndots
  #       value: "2"
  dnsConfig: {}

  softMultiTenancy:
    # enabled determines whether the operator is installed with soft multi-tenancy extensions.
    # This requires network policies to be enabled on the Kubernetes cluster.
    enabled: false

  # kubeAPIServerIP is required when softMultiTenancy is enabled.
  kubeAPIServerIP: null

  telemetry:
    # disabled determines whether the operator periodically updates ECK telemetry data for Kibana to consume.
    disabled: false
    # distributionChannel denotes which distribution channel was used to install the operator.
    distributionChannel: "helm"

  # config values for the operator.
  config:
    # logVerbosity defines the logging level. Valid values are as follows:
    # -2: Errors only
    # -1: Errors and warnings
    #  0: Errors, warnings, and information
    #  number greater than 0: Errors, warnings, information, and debug details.
    logVerbosity: "0"

    # (Deprecated: use metrics.port: will be removed in v2.14.0) metricsPort defines the port to expose operator metrics. Set to 0 to disable metrics reporting.
    metricsPort: 0

    metrics:
      # port defines the port to expose operator metrics. Set to 0 to disable metrics reporting.
      port: "0"
      # secureMode contains the options for enabling and configuring RBAC and TLS/HTTPs for the metrics endpoint.
      secureMode:
        # secureMode.enabled specifies whether to enable RBAC and TLS/HTTPs for the metrics endpoint.
        # * This option makes most sense when using a ServiceMonitor to scrape the metrics and is therefore mutually exclusive with the podMonitor.enabled option.
        # * This option also requires using cluster scoped resources (ClusterRole, ClusterRoleBinding) to
        #   grant access to the /metrics endpoint. (createClusterScopedResources: true is required)
        #
        enabled: false
        tls:
          # certificateSecret is the name of the tls secret containing the custom TLS certificate and key for the secure metrics endpoint.
          #
          # * This is an optional setting and is only required if you are using a custom TLS certificate. A self-signed certificate will be generated by default.
          # * TLS secret key must be named tls.crt.
          # * TLS key's secret key must be named tls.key.
          # * It is assumed to be in the same namespace as the ServiceMonitor.
          #
          # example: kubectl create secret tls eck-metrics-tls-certificate -n elastic-system \
          #            --cert=/path/to/tls.crt --key=/path/to/tls.key
          certificateSecret: ""

    # containerRegistry to use for pulling Elasticsearch and other application container images.
    containerRegistry: docker.elastic.co

    # containerRepository to use for pulling Elasticsearch and other application container images.
    # containerRepository: ""

    # containerSuffix suffix to be appended to container images by default. Cannot be combined with -ubiOnly flag
    # containerSuffix: ""

    # maxConcurrentReconciles is the number of concurrent reconciliation operations to perform per controller.
    maxConcurrentReconciles: "3"

    # caValidity defines the validity period of the CA certificates generated by the operator.
    caValidity: 8760h

    # caRotateBefore defines when to rotate a CA certificate that is due to expire.
    caRotateBefore: 24h

    # caDir defines the directory containing a CA certificate (tls.crt) and its associated private key (tls.key) to be used for all managed resources.
    # Setting this makes caRotateBefore and caValidity values ineffective.
    caDir: ""

    # certificatesValidity defines the validity period of certificates generated by the operator.
    certificatesValidity: 8760h

    # certificatesRotateBefore defines when to rotate a certificate that is due to expire.
    certificatesRotateBefore: 24h

    # disableConfigWatch specifies whether the operator watches the configuration file for changes.
    disableConfigWatch: false

    # exposedNodeLabels is an array of regular expressions of node labels which are allowed to be copied as annotations on Elasticsearch Pods.
    exposedNodeLabels:
      ["topology.kubernetes.io/.*", "failure-domain.beta.kubernetes.io/.*"]

    # ipFamily specifies the IP family to use. Possible values: IPv4, IPv6 and "" (auto-detect)
    ipFamily: ""

    # setDefaultSecurityContext determines whether a default security context is set on application containers created by the operator.
    # *note* that the default option now is "auto-detect" to attempt to set this properly automatically when both running
    # in an openshift cluster, and a standard kubernetes cluster.  Valid values are as follows:
    # "auto-detect" : auto detect
    # "true"        : set pod security context when creating resources.
    # "false"       : do not set pod security context when creating resources.
    setDefaultSecurityContext: "auto-detect"

    # kubeClientTimeout sets the request timeout for Kubernetes API calls made by the operator.
    kubeClientTimeout: 60s

    # elasticsearchClientTimeout sets the request timeout for Elasticsearch API calls made by the operator.
    elasticsearchClientTimeout: 180s

    # policies contains policies for the operator, currently only password generation policies are supported.
    policies: {}
      # passwords:
      #   length: 24

    # validateStorageClass specifies whether storage classes volume expansion support should be verified.
    # Can be disabled if cluster-wide storage class RBAC access is not available.
    validateStorageClass: true

    # enableLeaderElection specifies whether leader election should be enabled
    enableLeaderElection: true

    # Interval between observations of Elasticsearch health, non-positive values disable asynchronous observation.
    elasticsearchObservationInterval: 10s

    # ubiOnly specifies whether the operator will use only UBI container images to deploy Elastic Stack applications as well as for its own StatefulSet image. UBI images are only available from 7.10.0 onward.
    # Cannot be combined with the containerSuffix value.
    ubiOnly: false

  # Prometheus PodMonitor configuration
  # Reference: https://github.com/prometheus-operator/prometheus-operator/blob/master/Documentation/api.md#podmonitor
  podMonitor:
    # enabled determines whether a podMonitor should deployed to scrape the eck metrics.
    # This requires the prometheus operator and the config.metrics.port not to be 0
    enabled: false

    # labels adds additional labels to the podMonitor
    labels: {}

    # annotations adds additional annotations to the podMonitor
    annotations: {}

    # namespace determines in which namespace the podMonitor will be deployed.
    # If not set the podMonitor will be created in the namespace where the Helm release is installed into
    # namespace: monitoring

    # interval specifies the interval at which metrics should be scraped
    interval: 5m

    # scrapeTimeout specifies the timeout after which the scrape is ended
    scrapeTimeout: 30s

    # podTargetLabels transfers labels on the Kubernetes Pod onto the target.
    podTargetLabels: []

    # podMetricsEndpointConfig allows to add an extended configuration to the podMonitor
    podMetricsEndpointConfig: {}
    # honorTimestamps: true

  # Prometheus ServiceMonitor configuration
  # Only used when config.enableSecureMetrics is true
  # Reference: https://github.com/prometheus-operator/prometheus-operator/blob/master/Documentation/api.md#servicemonitor
  serviceMonitor:
    # This option requires the following settings within Prometheus to function:
    # 1. RBAC settings for the Prometheus instance to access the metrics endpoint.
    #
    # - nonResourceURLs:
    #   - /metrics
    #   verbs:
    #   - get
    #
    # 2. If using the Prometheus Operator and your Prometheus instance is not in the same namespace as the operator you will need
    #    the Prometheus Operator configured with the following Helm values:
    #
    #   prometheus:
    #     prometheusSpec:
    #       serviceMonitorNamespaceSelector: {}
    #       serviceMonitorSelectorNilUsesHelmValues: false
    #
    # allows to disable the serviceMonitor, enabled by default for backwards compatibility
    enabled: true
    # namespace determines in which namespace the serviceMonitor will be deployed.
    # If not set the serviceMonitor will be created in the namespace where the Helm release is installed into
    # namespace: monitoring
    # caSecret is the name of the secret containing the custom CA certificate used to generate the custom TLS certificate for the secure metrics endpoint.
    #
    # * This *must* be the name of the secret containing the CA certificate used to sign the custom TLS certificate for the metrics endpoint.
    # * This secret *must* be in the same namespace as the Prometheus instance that will scrape the metrics.
    # * If using the Prometheus operator this secret must be within the `spec.secrets` field of the `Prometheus` custom resource such that it is mounted into the Prometheus pod at `caMountDirectory`, which defaults to /etc/prometheus/secrets/{secret-name}.
    # * This is an optional setting and is only required if you are using a custom TLS certificate.
    # * Key must be named ca.crt.
    #
    # example: kubectl create secret generic eck-metrics-tls-ca -n monitoring \
    #            --from-file=ca.crt=/path/to/ca.pem
    caSecret: ""
    # caMountDirectory is the directory at which the CA certificate is mounted within the Prometheus pod.
    #
    # * You should only need to adjust this if you are *not* using the Prometheus operator.
    caMountDirectory: "/etc/prometheus/secrets/"
    # insecureSkipVerify specifies whether to skip verification of the TLS certificate for the secure metrics endpoint.
    #
    # * If this setting is set to false, then the following settings are required:
    #   - certificateSecret
    #   - caSecret
    insecureSkipVerify: true

##############################
# ECK-Elasticsearch subchart #
##############################

eck-elasticsearch:
  enabled: true
  nameOverride: "openinwoner-elasticsearch"
  fullnameOverride: "openinwoner-elasticsearch"

  # Version of Elasticsearch.
  #
  version: 9.2.0

  # Elasticsearch Docker image to deploy
  #
  # image:

  # Labels that will be applied to Elasticsearch.
  #
  labels: {}

  # Annotations that will be applied to Elasticsearch.
  #
  annotations: {}

  # Settings for configuring Elasticsearch users and roles.
  # ref: https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-users-and-roles.html
  #
  auth: {}

  # Settings for configuring stack monitoring.
  # ref: https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-stack-monitoring.html
  #
  monitoring: {}
    # metrics:
    #   elasticsearchRefs:
    #   - name: monitoring
    #     namespace: observability
    # logs:
    #   elasticsearchRefs:
    #   - name: monitoring
    #     namespace: observability

  # Control the Elasticsearch transport module used for internal communication between nodes.
  # ref: https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-transport-settings.html
  #
  transport: {}
    # service:
    #   metadata:
    #     labels:
    #       my-custom: label
    #   spec:
    #     type: LoadBalancer
    # tls:
    #   subjectAltNames:
    #     - ip: 1.2.3.4
    #     - dns: hulk.example.com
    #   certificate:
    #     secretName: custom-ca

  # Settings to control how Elasticsearch will be accessed.
  # ref: https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-accessing-elastic-services.html
  #
  http: {}
    # service:
    #   metadata:
    #     labels:
    #       my-custom: label
    #   spec:
    #     type: LoadBalancer
    # tls:
    #   selfSignedCertificate:
    #     # To fully disable TLS for the HTTP layer of Elasticsearch, simply
    #     # set the below field to 'true', removing all other fields.
    #     disabled: false
    #     subjectAltNames:
    #       - ip: 1.2.3.4
    #       - dns: hulk.example.com
    #   certificate:
    #     secretName: custom-ca

  # Control Elasticsearch Secure Settings.
  # ref: https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-es-secure-settings.html#k8s-es-secure-settings
  #
  secureSettings: []
    # - secretName: one-secure-settings-secret
    # Projection of secret keys to specific paths
    # - secretName: gcs-secure-settings
    #   entries:
    #   - key: gcs.client.default.credentials_file
    #   - key: gcs_client_1
    #     path: gcs.client.client_1.credentials_file
    #   - key: gcs_client_2
    #     path: gcs.client.client_2.credentials_file

  # Settings for limiting the number of simultaneous changes to an Elasticsearch resource.
  # ref: https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-update-strategy.html
  #
  updateStrategy: {}
    # changeBudget:
    #   maxSurge: 3
    #   maxUnavailable: 1

  # Controlling of connectivity between remote clusters within the same kubernetes cluster.
  # ref: https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-remote-clusters.html
  #
  remoteClusters: {}
    # - name: cluster-two
    #   elasticsearchRef:
    #     name: cluster-two
    #     namespace: ns-two

  # RemoteClusterServer specifies if the remote cluster server should be enabled.
  # This must be enabled if this cluster is a remote cluster which is expected to be accessed using API key authentication.
  #
  remoteClusterServer: {}
  #   enabled: true

  # VolumeClaimDeletePolicy sets the policy for handling deletion of PersistentVolumeClaims for all NodeSets.
  # Possible values are DeleteOnScaledownOnly and DeleteOnScaledownAndClusterDeletion.
  # By default, if not set or empty, the operator sets DeleteOnScaledownAndClusterDeletion.
  #
  volumeClaimDeletePolicy: ""

  # Settings to limit the disruption when pods need to be rescheduled for some reason such as upgrades or routine maintenance.
  # By default, if not set, the operator sets a budget that doesn't allow any pod to be removed in case the cluster is not green or if there is only one node of type `data` or `master`.
  # In all other cases the default PodDisruptionBudget sets `minUnavailable` equal to the total number of nodes minus 1.
  # To completely disable the pod disruption budget set `disabled` to true.
  #
  # podDisruptionBudget:
  #   spec:
  #     minAvailable: 2
  #     selector:
  #       matchLabels:
  #         elasticsearch.k8s.elastic.co/cluster-name: quickstart
  #   disabled: true

  # Used to check access from the current resource to a resource (for ex. a remote Elasticsearch cluster) in a different namespace.
  # Can only be used if ECK is enforcing RBAC on references.
  #
  # serviceAccountName: ""

  # Number of revisions to retain to allow rollback in the underlying StatefulSets.
  # By default, if not set, Kubernetes sets 10.
  #
  # revisionHistoryLimit: 2

  # Node configuration settings.
  # The node roles which can be configured here are:
  # - "master"
  # - "data_hot"
  # - "data_cold"
  # - "data_frozen"
  # - "data_content"
  # - "ml"
  # - "ingest"
  # ref: https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-node-configuration.html
  #
  nodeSets:
  - name: default
    count: 1
    config:
      # Comment out when setting the vm.max_map_count via initContainer, as these are mutually exclusive.
      # For production workloads, it is strongly recommended to increase the kernel setting vm.max_map_count to 262144
      # and leave node.store.allow_mmap unset.
      # ref: https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-virtual-memory.html
      #
      node.store.allow_mmap: false
    podTemplate:
      # The following spec is exactly the Kubernetes Core V1 PodTemplateSpec. Any fields within the PodTemplateSpec
      # are supported within the 'spec' field below.  Please see below documentation for the exhaustive list of fields.
      #
      # https://v1-24.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#podtemplatespec-v1-core
      #
      # Only the commonly overridden/used fields will be noted below.
      #
      spec:

        # If specified, the pod's scheduling constraints
        # https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-advanced-node-scheduling.html
        # https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/
        # affinity:
        #   nodeAffinity:
        #     requiredDuringSchedulingIgnoredDuringExecution:
        #       nodeSelectorTerms:
        #       - matchExpressions:
        #         - key: topology.kubernetes.io/zone
        #           operator: In
        #           values:
        #           - antarctica-east1
        #           - antarctica-west1

        # Containers array.  Should only be used to customize the 'elasticsearch' container using the following fields.
        containers:
        - name: elasticsearch

          # List of environment variables to set in the 'elasticsearch' container.
          # https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/
          # env:
          # - name: "my-env-var"
          #   value: "my-value"

          # Compute Resources required by this container.
          resources:
            # Requests describes the minimum amount of compute resources required. If Requests is omitted for a container,
            # it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value.
            #
            # Defaults used by the ECK Operator, if not specified, are below
            limits:
              # cpu: 1
              memory: 2Gi
            requests:
              # cpu: 1
              memory: 2Gi

            # Example increasing both the requests and limits values:
            # limits:
            #   cpu: 4
            #   memory: 8Gi
            # requests:
            #   cpu: 1
            #   memory: 8Gi

          # SecurityContext defines the security options the container should be run with.
          # If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
          #
          # These typically are set automatically by the ECK Operator, and should only be adjusted
          # with the full knowledge of the effects of each field.
          #
          # securityContext:

            # Whether this container has a read-only root filesystem. Default is false.
            # readOnlyRootFilesystem: false

            # The GID to run the entrypoint of the container process. Uses runtime default if unset.
            # runAsGroup: 1000

            # Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure
            # that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed.
            # runAsNonRoot: true

            # The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified.
            # runAsUser: 1000

      # ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
      # https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
      # imagePullSecrets:
      # - name: "image-pull-secret"

      # List of initialization containers belonging to the pod.
      #
      # Common initContainers include setting sysctl, or in 7.x versions of Elasticsearch,
      # installing Elasticsearch plugins.
      #
      # https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
      # initContainers:
      # - command:
      #   - sh
      #   - "-c"
      #   - sysctl -w vm.max_map_count=262144
      #   name: sysctl
      #   securityContext:
      #     privileged: true
      # - command:
      #   - sh
      #   - "-c"
      #   - bin/elasticsearch-plugin remove --purge analysis-icu ; bin/elasticsearch-plugin install --batch analysis-icu
      #   name: install-plugins
      #   securityContext:
      #     privileged: true


      # NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node.
      # https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
      # https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-advanced-node-scheduling.html
      # nodeSelector:
      #   diskType: ssd
      #   environment: production

      # If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority.
      # Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
      # https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/
      # priorityClassName: ""

      # SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty. See type description for default values of each field.
      # See previously defined 'securityContext' within 'podTemplate' for all available fields.
      # securityContext: {}

      # ServiceAccountName is the name of the ServiceAccount to use to run this pod.
      # https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
      # serviceAccountName: ""

      # Optional duration in seconds to wait for the Elasticsearch pod to terminate gracefully.
      # terminationGracePeriodSeconds: 30s

      # If specified, the pod's tolerations that will apply to all containers within the pod.
      # https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
      # tolerations:
      # - key: "node-role.kubernetes.io/elasticsearch"
      #   effect: "NoSchedule"
      #   operator: "Exists"

      # TopologySpreadConstraints describes how a group of pods ought to spread across topology domains.
      # Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.
      #
      # These settings are generally applied within each `nodeSets[].podTemplate` field to apply to a specific Elasticsearch nodeset.
      #
      # https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-advanced-node-scheduling.html
      # topologySpreadConstraints: {}

      # List of volumes that can be mounted by containers belonging to the pod.
      # https://kubernetes.io/docs/concepts/storage/volumes
      # volumes: []

  # Settings for controlling Elasticsearch ingress. Enabling ingress will expose your Elasticsearch instance
  # to the public internet, and as such is disabled by default.
  #
  # Each Cloud Service Provider has different requirements for setting up Ingress. Some links to common documentation are:
  # - AWS:   https://docs.aws.amazon.com/eks/latest/userguide/alb-ingress.html
  # - GCP:   https://cloud.google.com/kubernetes-engine/docs/concepts/ingress
  # - Azure: https://learn.microsoft.com/en-us/azure/aks/app-routing
  # - Nginx: https://kubernetes.github.io/ingress-nginx/
  #
  ingress:
    enabled: false

    # Annotations that will be applied to the Ingress resource. Note that some ingress controllers are controlled via annotations.
    # 
    # Nginx Annotations: https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/
    #
    # Common annotations:
    #   kubernetes.io/ingress.class: gce          # Configures the Ingress resource to use the GCE ingress controller and create an external Application Load Balancer.
    #   kubernetes.io/ingress.class: gce-internal # Configures the Ingress resource to use the GCE ingress controller and create an internal Application Load Balancer.
    #   kubernetes.io/ingress.class: nginx        # Configures the Ingress resource to use the NGINX ingress controller.
    #
    annotations: {}

    # Labels that will be applied to the Ingress resource.
    #
    labels: {}

    # Some ingress controllers require the use of a specific class name to route traffic to the correct controller, notably AKS and EKS, which
    # replaces the use of the 'kubernetes.io/ingress.class' annotation.
    #
    # className: webapprouting.kubernetes.azure.com | alb

    # Ingress paths are required to have a corresponding path type. Defaults to 'Prefix'.
    #
    # There are 3 supported path types:
    # - ImplementationSpecific
    # - Prefix
    # - Exact
    #
    # ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types
    #
    pathType: Prefix

    # Hosts are a list of hosts included in the Ingress definition, with a corresponding path at which the default Elasticsearch service
    # will be exposed. Each host in the list should be a fully qualified DNS name that will resolve to the exposed Ingress object.
    #
    # ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#name-based-virtual-hosting
    #
    hosts:
      - host: chart-example.local
        path: /

    # TLS defines whether TLS will be enabled on the Ingress resource.
    #
    # *NOTE* Many Cloud Service Providers handle TLS in a custom manner, and as such, it is recommended to consult their documentation.
    # Notably GKE and Nginx Ingress Controllers seems to respect the Ingress TLS settings, AKS and EKS ignore it.
    #
    # - AKS:   https://learn.microsoft.com/en-us/azure/aks/app-routing-dns-ssl
    # - GKE:   https://cloud.google.com/kubernetes-engine/docs/concepts/ingress#options_for_providing_ssl_certificates
    # - EKS:   https://aws.amazon.com/blogs/containers/serve-distinct-domains-with-tls-powered-by-acm-on-amazon-eks/
    # - Nginx: https://kubernetes.github.io/ingress-nginx/user-guide/tls/
    #
    # Kubernetes ingress TLS documentation:
    # ref: https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
    #
    tls:
      enabled: false
      # Optional Kubernetes secret name that contains a base64 encoded PEM certificate and private key that corresponds to the above 'hosts' definitions.
      # If tls is enabled, but this field is not set, the self-signed certificate and key created by the ECK operator will be used.
      # secretName: chart-example-tls

